<!-- SPDX-License-Identifier: zlib-acknowledgement -->

## Question 1
1.1 Construct min-heap O(n)
   add top of heap with min(left, right)
   remove top of heap O(logn)
   insert computed sum O(logn)

like huffman coding?: https://cs.stackexchange.com/questions/112638/minimize-cost-of-recursive-pairwise-sums-how-to-prove-the-greedy-solution-works

1.2
construct red-black tree of pipes
side to add to is min(len(left), len(right))
compute current difference: d = (len(left) - len(right))
search for smallest pipe1 that is >= d and smallest pipe2 <= d
add min((pipe1 - d), (d - pipe2))

## Question 2
https://math.stackexchange.com/questions/3438672/an-algorithm-to-find-every-induced-subgraph-that-is-a-tree

Induced subgraph can only delete vertices
2.1:
x is adjacent to 2 vertices.
if k=3, must be adjacent to at least 3 vertices

2.2:
(x, 2)
(j, 2)
(a, 2)

8 remaining vertices
(h, 4 - 1)
(b, 4 - 1)
(i, 3)
(c, 3)
(f, 3)
(d, 4)
(g, 4)
(e, 3)


2.3:
https://stackoverflow.com/questions/10205191/graph-how-to-find-maximum-induced-subgraph-h-of-g-such-that-each-vertex-in-h-h

for vertex_subset in vertex_subsets:
  for v in vertex_subset:
    for u in vertex_subset:
      if M[v, u] == 1:
        v_edge_count += 1


vertex_edges_dirty = true
while vertex_edges_dirty:
  # only need to find max vertex edge count?
  vertex_edges = calculate_vertex_edges(M)

  vertex_edges_dirty = false 
  for vertex_edge in vertex_edges:
    if vertex_edge.count < k or (num_vertices - vertex_edge.count) < k:
      remove_vertex(M, vertex_edge.vertex)
      vertex_edges_dirty = true

return vertices of vertex_edges

O(n)·(O(n^2) + O(n)·O(n^2))


for v in adjacency_list:
  


