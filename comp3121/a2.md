<!-- SPDX-License-Identifier: zlib-acknowledgement -->

## Question 1
You might say things like "choose the two rods ... and ..., then weld them together to produce a new rod which we will call ...".


1.1 Construct min-heap O(n)
   add top of heap with min(left, right)
   remove top of heap O(logn)
   insert computed sum O(logn)

like huffman coding?: https://cs.stackexchange.com/questions/112638/minimize-cost-of-recursive-pairwise-sums-how-to-prove-the-greedy-solution-works

1.2
construct red-black tree of pipes
side to add to is min(len(left), len(right))
compute current difference: d = (len(left) - len(right))
search for smallest pipe1 that is >= d and smallest pipe2 <= d
add min((pipe1 - d), (d - pipe2))

## Question 2
https://math.stackexchange.com/questions/3438672/an-algorithm-to-find-every-induced-subgraph-that-is-a-tree

Induced subgraph can only delete vertices
2.1:
x is adjacent to 2 vertices.
if k=3, must be adjacent to at least 3 vertices

2.2:
(x, 2)
(j, 2)
(a, 2)

8 remaining vertices
(h, 4 - 1)
(b, 4 - 1)
(i, 3)
(c, 3)
(f, 3)
(d, 4)
(g, 4)
(e, 3)


2.3:
while True:
  vertex_edges = calculate_vertex_edges(M)

  if no_vertices_left:
    no_solution
  
  if (num_vertices - max_vertex_edge_count) < k:
    remove_vertex()
  elif min_vertex_edge_count < k:
    no_solution
  else:
    return vertices of vertex_edges



O(n)Â·(O(n^2) + O(n))


## Question 3
3.1:

https://edstem.org/au/courses/11846/discussion/1451373
