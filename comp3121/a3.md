<!-- SPDX-License-Identifier: zlib-acknowledgement -->

IMPORTANT: DP will create a table. the next step may change current step optimal choice

IMPORTANT: the dependencies are set up working way down the recursion stack, i.e. will not pick conflicting animals.
Working way up they will be evaluated


IMPORTANT (to view marks): https://wiki.cse.unsw.edu.au/give  

https://edstem.org/au/courses/11846/discussion/1460888
activity selection in lectures for optimisation proof of DP?

https://courageous-postbox-384.notion.site/COMP3121-Tutorials-7490cbbb823044fcac4453661746ab42

## 1
R(city, a1, a2)
d(city)
v(animal)

max{opt(j) : f_j < s_i (this indicates no conflicting)} + p_i

argmax (index for which result is maximum)

1.1
t = d/s
from c0:
G7, M3, A2, I1, L4
from c1:
$G-M: (1/7)+(3/3) = 1.1$ \\
$A-M: (1/2)+(3/3) = 1.5$ \\ 
$A-A: (1/2)+(3/2) = 2$ \\ 
$I-G: (1/1)+(3/7) = 1.4$ \\ 
$L-I: (1/4)+(3/1) = 3.25$ \\

1.2
    \frac{d(i)}{v(G)}\\
    \frac{d(i)}{v(M)}\\
    \frac{d(i)}{v(A)}\\
    \frac{d(i)}{v(I)}\\
    \frac{d(i)}{v(L)}
1.3
At each stage, look for all previous cities for same animal to calculate epsilon

## 2
2.1
p = []
for i in word:
  
